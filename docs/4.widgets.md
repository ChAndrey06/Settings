## Пассивные виджеты
### Label, LabelNum, LabelFloat
Виджет для отображения текста или цифры. Значение обновляется через `update`, поддерживает изменение цвета через `updateColor`.

### LED
Светодиод, имеет два цвета. Состояние переключает между этими цветами, по умолчанию красный и зелёный, можно задать свои два цвета. Значение состояния обновляется через `update`, также поддерживает изменение цвета напрямую через `updateColor` независимо от состояния.

### Image
Вывод изображения:
- Из Интернета - ссылка начинается с `http`
- Из Flash-памяти - ссылка начинается с `/`

При отправке обновления `update` изображение будет обновлено на новый url.

### Paragraph
Вывод строки текста.

### HTML
Вывод кода в HTML разметке:

```cpp
b.HTML("", R"(<a href="http://google.com">Google</a>)");
```

### Stream
Для запуска стрима с ESP32-CAM нужно подключить `SettingsCamera.h`, в нём можно настроить тип камеры и подключение. Для плат ESP32-CAM AiThinker ничего трогать не нужно. Для запуска стрима нужно инициализировать камеру и запустить стрим, он будет выводиться в виджет `Stream`:

```cpp
bool sets::cameraInit(framesize_t frame_size = FRAMESIZE_VGA, pixformat_t pixel_format = PIXFORMAT_JPEG, int jpeg_quality = 12);
void sets::streamBegin(uint16_t fps = 30, uint16_t port = 82, const char* path = "/stream");
void sets::streamEnd();
```

```cpp
#include <SettingsCamera.h>

void build(sets::Builder& b) {
    b.Stream();
}

void setup() {
    sets::cameraInit();
    sets::streamBegin();
}
```

### Log
Готовый инструмент для ведения логов и отправки в вебморду (почти Web-Serial) - `Logger`:

```cpp
sets::Logger logger(150);   // размер буфера

void build(sets::Builder& b) {
    b.Log(H(log), logger);

    if (b.Button("Test")) {
        // печатать как в Serial в любом месте в программе
        logger.println(millis());
    }
}

void update(sets::Updater& upd) {
    // отправить лог
    upd.update(H(log), logger);
}
```

## Активные виджеты
### Input
Ввод текста. Поддерживает регулярные выражения и комментарий при ошибке ввода:

```cpp
b.Input("");
b.Input("", nullptr, R"(^\d+$)");
b.Input("", nullptr, R"(^\d+$)", "Только цифры");
```

### Pass
Ввод пароля.

### Number
Ввод цифр.

### Color
Колор-пике, принимает и отправляет цвет в 24-битном формате RRGGBB.

### Switch
Переключатель. поддерживает изменение цвета через `updateColor`.

### Date, DateTime
Дата и дата-время, принимает и отправляет unix-секунды (GMT+0). В браузере выводится с учётом часового пояса браузера, также локальный часовой пояс можно указать вручную.

### Time
Принимает и отправляет время в секундах с начала суток независимо от часового пояса.

### Slider
Слайдер для ввода значений, при движении отправляет значения с указанным в настройках вебморды периодом. Строка результата кликабельная, можно задать значение вручную - подчиняется настройкам min/max/step.

### Slider2
Двойной слайдер, имеет два ID для минимума и максимума, переменных тоже можно подключить две. Обновляется через метод `update2`.

### Select
Выпадающий список, принимает и отправляет индекс опции (начиная с 0). Опции передаются в виде строки с разделителем `;`: `"option 1;option 2;my option"`.

### Tabs
Вкладки, принимает и отправляет индекс вкладки (начиная с 0). Имена вкладок передаются в виде строки с разделителем `;`: `"tab 1;tab 2;my tab"`. Если вкладок слишком много - их можно перемещать пальцем и курсором. Вернёт `true` при клике по вкладке. Далее в программе можно строить билдер по условиям или в `switch` исходя из значения вкладки.

```cpp
void build(sets::Builder& b) {
    static uint8_t tab; // статическая

    if (b.Tabs("Slider;Button;Input", &tab)) {
        // при нажатии перезагружаемся и выходим
        b.reload();
        return;
    }

    if (tab == 0) {
        b.Slider();
    } else if (tab == 1) {
        b.Button();
    } else if (tab == 2) {
        b.Input();
    }
}
```

Пример с использованием `enum` для читаемости кода:

```cpp
void build(sets::Builder& b) {
    enum Tabs : uint8_t {
        Slider,
        Button,
        Input,
    } static tab;

    if (b.Tabs("Slider;Button;Input", (uint8_t*)&tab)) {
        // при нажатии перезагружаемся и выходим
        b.reload();
        return;
    }

    switch (tab) {
        case Tabs::Slider:
            b.Slider();
            break;
            
        case Tabs::Button:
            b.Button();
            break;

        case Tabs::Input:
            b.Input();
            break;
    }
}
```

### Button
Кнопка. Можно обновлять текст на кнопке через `update` и цвет через `updateColor`. функция вернёт `true` при клике по кнопке.

```cpp
if (b.Button()) {
    Serial.println("Click!");
}
```

### ButtonHold
Кнопка с двумя состояниями. Можно обновлять текст на кнопке через `update` и цвет через `updateColor`. Функция вернёт `true` при нажатии и при отпускании. Для определения состояния нужно опросить `b.build.pressed()`.

```cpp
if (b.ButtonHold()) {
    Serial.println(b.build.pressed());
}
```

### Confirm
Всплывающее окно подтверждения. Функция вернёт `true` при любом выборе юзера. Для определения что именно выбрал юзер можно опросить `b.build.value.toBool()` или подключить `bool` переменную. Для вызова окна нужно отправить обновление с id виджета:

- Если отправить обновление `upd.confirm(id)` - вызовется окно с текстом, заданным в билдере
- Если отправить `upd.update(id, текст)` - вызовется окно с текстом, указанным в апдейте, а текст виджета обновится

```cpp
// вызов Confirm по кнопке
bool cfm_f;

void build(sets::Builder& b) {
    bool res;
    if (b.Confirm(kk::conf, "Confirm", &res)) {
        Serial.println(res);
        // Serial.println(b.build.value.toBool());
    }

    if (b.Button()) cfm_f = true;
}

void update(sets::Updater& u) {
    if (cfm_f) {
        cfm_f = false;
        u.confirm(kk::conf);
    }
}
```